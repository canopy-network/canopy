syntax = "proto3";
package types;

option go_package = "github.com/canopy-network/canopy/lib";

import "tx.proto";
import "certificate.proto";
import "crypto.proto";
import "event.proto";
import "swap.proto";
import "dex.proto";

// *****************************************************************************************************
// This file is auto-generated from source files in `/lib/.proto/*` using Protocol Buffers (protobuf)
//
// Protobuf is a language-neutral, platform-neutral serialization format. It allows users
// to define objects in a way that’s both efficient to store and fast to transmit over the network.
// These definitions are compiled into code that *enables different systems and programming languages
// to communicate in a byte-perfect manner*
//
// To update these structures, make changes to the source .proto files, then recompile
// to regenerate this file.
// These auto-generated files are easily recognized by checking for a `.pb.go` ending
// *****************************************************************************************************
//_
//_
//_
// A block_header contains essential summary information about a block, like its unique identifier (hash), the previous
// block’s hash, timestamp, and block height. All of which help secure the block and connect it to the chain.
message BlockHeader {
  // height: the number of blocks in the blockchain before a specific block, indicating its position in the chain
  // and representing the blockchain's length
  uint64 height = 1;
  // hash: a unique identifier for a block, generated by applying a cryptographic hash function to the block's contents,
  // ensuring its integrity and connecting it to the previous block in the chain.
  bytes hash = 2;
  // network_id: a unique identifier used to distinguish different canopy blockchain networks, ensuring that
  // transactions and blocks are only processed within the correct network
  uint32 network_id = 3;  // @gotags: json:"networkID"
  // time: specific time recorded in a block when it is created by the proposer, indicating when the block was proposed
  uint64 time = 4;
  // num_txs: the count of transactions in the block
  uint64 num_txs = 5; // @gotags: json:"numTxs"
  // total_txs: the count of transactions in the blockchain
  uint64 total_txs = 6; // @gotags: json:"totalTxs"
  // total_vdf_iterations: the total number of verifiable random delay function iterations in the blockchain
  uint64 total_vdf_iterations = 7; // @gotags: json:"totalVDFIterations"
  // last_block_hash: the unique identifier of the previous block, chaining this block to the previous, ensuring the
  // continuity of the blockchain
  bytes last_block_hash = 8; // @gotags: json:"lastBlockHash"
  // state_root: the merkle root of the 'state commit store' representing  the entire state of the blockchain at
  // this height
  bytes state_root = 9; // @gotags: json:"stateRoot"
  // transaction_root: the merkle root of the 'transactions' included in this block
  bytes transaction_root = 10; // @gotags: json:"transactionRoot"
  // validator_root: the merkle root of the validators that signed the quorum certificate for this height
  // ensuring that the list of validators (who are responsible for proposing and validating blocks) is consistent
  // and tamper-proof, allowing participants to independently verify the integrity of the validator set at any point
  // in the blockchain
  bytes validator_root = 11; // @gotags: json:"validatorRoot"
  // next_validator_root: the merkle root of the validators who are responsible for proposing and validating the next
  // block - ensuring smooth transitions between validator sets. This design allows lite-node operations as just with
  // the block_headers a node is able to validate the signers of the entire blockchain
  bytes next_validator_root = 12; // @gotags: json:"nextValidatorRoot"
  // proposer_address: is the short version of the public key of the Validator who proposed this block
  bytes proposer_address = 13; // @gotags: json:"proposerAddress"
  // vdf: the verifiable delay proof for this block. The VDF serves as a protection mechanism against historical
  // forking attacks
  VDF vdf = 14;
  // last_quorum_certificate: The quorum certificate from the previous block is included in the block header to ensure
  // all nodes have the same record of blockchain certificates, preventing discrepancies where the same block
  // could be accepted with different super-majorities of signatures across nodes.
  QuorumCertificate last_quorum_certificate = 15; // @gotags: json:"lastQuorumCertificate"
}

// A block is a batch of transactions and essential header information that marks a unit of committed information in the
// blockchain. Blocks are linked together in a sequence, creating a secure, verifiable chain of transaction history.
message Block {
  // block_header: is the essential summary information of the block
  BlockHeader block_header = 1; // @gotags: json:"blockHeader"
  // transactions: is the batch of transactions in this block
  repeated bytes transactions = 2;
}

// a block_result is a batch of transaction results, essential header information, and non-essential metadata about
// processing that block. A block result is made by applying a 'block' against a state machine.
message BlockResult {
  // block_header: is the essential summary information of the block
  BlockHeader block_header = 1; // @gotags: json:"blockHeader"
  // transactions: is a batch of transaction results in this block
  repeated TxResult transactions = 2;
  // events: the events associated with the block
  repeated Event events = 3;
  // meta: is non-essential metadata about the processing of this block
  BlockResultMeta meta = 4;
}

// block_result_meta is non-essential information about the processing of a block
message BlockResultMeta {
  // size: number of bytes in the block
  uint64 size = 1;
  // took: duration string of the block in milliseconds
  uint64 took = 2;
}

// IndexerSnapshot is a comprehensive state snapshot for indexers sent over WebSocket
// Uses raw slices instead of Page wrappers for proto compatibility
message IndexerSnapshot {
  uint64 height = 1;

  // Block data
  BlockResult block = 2;
  repeated TxResult transactions = 3;
  repeated Event events = 4;

  // State data (current height)
  repeated bytes accounts = 5;           // serialized Account messages
  OrderBooks orders = 6;
  repeated bytes dex_prices = 7;         // serialized DexPrice structs @gotags: json:"dexPrices"
  bytes params = 8;                      // serialized Params message
  bytes supply = 9;                      // serialized Supply message
  CommitteesData committees_data = 10;   // @gotags: json:"committeesData"
  repeated uint64 subsidized_committees = 11; // @gotags: json:"subsidizedCommittees"
  repeated uint64 retired_committees = 12;    // @gotags: json:"retiredCommittees"

  // Change detection pairs (current + previous)
  repeated bytes validators_current = 13;    // @gotags: json:"validatorsCurrent"
  repeated bytes validators_previous = 14;   // @gotags: json:"validatorsPrevious"
  repeated bytes pools_current = 15;         // @gotags: json:"poolsCurrent"
  repeated bytes pools_previous = 16;        // @gotags: json:"poolsPrevious"
  bytes non_signers_current = 17;            // @gotags: json:"nonSignersCurrent"
  bytes non_signers_previous = 18;           // @gotags: json:"nonSignersPrevious"
  repeated DoubleSigner double_signers_current = 19;  // @gotags: json:"doubleSignersCurrent"
  repeated DexBatch dex_batches_current = 20;         // @gotags: json:"dexBatchesCurrent"
  repeated DexBatch dex_batches_previous = 21;        // @gotags: json:"dexBatchesPrevious"
  repeated DexBatch next_dex_batches_current = 22;    // @gotags: json:"nextDexBatchesCurrent"
  repeated DexBatch next_dex_batches_previous = 23;   // @gotags: json:"nextDexBatchesPrevious"
}
